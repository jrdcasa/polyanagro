<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.8.4" />
<title>polyanagro.internal_coordinates API documentation</title>
<meta name="description" content="Miscellany of mathematical functions" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.18.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.18.1/highlight.min.js" integrity="sha256-eOgo0OtLL4cdq7RdwRUiGKLX9XsIJ7nGhWEKbohmVAQ=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>polyanagro.internal_coordinates</code></h1>
</header>
<section id="section-intro">
<p>Miscellany of mathematical functions</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;
Miscellany of mathematical functions
&#34;&#34;&#34;
import math
import numpy as np
import random

# #############################################################################
def distance_array(ref, conf, openmp=False):
    &#34;&#34;&#34;
    Calculate the distances among the points in two arrays using C and Cython

    Parameters:
        * ``ref``: (type: ndarray): Reference array containing a number of points with shape [npoints1, dim], where dim is the dimension in 2-D or 3-D points
        * ``conf``: (type: ndarray): Reference array containing a number of points with shape [npoints2, dim], where dim is the dimension in 2-D or 3-D points
        * ``openmp``: (type: boolean) Parallel or not

    Returns:
        * ``dist``: (type: 2D-ndarray). Distances in Angstroms between the ith atom (row) and the jth atoms
        * ``rijx``: (type: 2D-ndarray). Component-x of the vector i,j
        * ``rijy``: (type: 2D-ndarray). Component-y of the vector i,j
        * ``rijz``: (type: 2D-ndarray). Component-z of the vector i,j

    ``Examples``:
    &gt;&gt;&gt; a
    &gt;&gt;&gt; a

    &#34;&#34;&#34;

    if openmp:
        from ext_libc.c_distances_openmp import calc_distance_array_openmp
        #from c_distances_openmp import calc_distance_array_openmp
    else:
        from ext_libc.c_distances import calc_distance_array
        #from c_distances import calc_distance_array

    rows = ref.shape[0]
    cols = conf.shape[0]
    dist = np.zeros([rows,cols])
    rijx = np.zeros([rows,cols])
    rijy = np.zeros([rows,cols])
    rijz = np.zeros([rows,cols])
    if openmp:
        calc_distance_array_openmp(ref, conf, dist, rijx, rijy, rijz)
    else:
        calc_distance_array(ref, conf, dist, rijx, rijy, rijz)

    return dist, rijx, rijy, rijz

# #############################################################################
def distance_diagonal_array(ref, conf, openmp=False):
    &#34;&#34;&#34;Calculate the distances among the points in two arrays using C and Cython

    ``Parameters``:
        * **ref**: (type: ndarray): Reference array containing a number of points with shape [npoints, dim], where dim is the dimension in 2-D or 3-D points
        * **conf**: (type: ndarray): Reference array containing a number of points with shape [npoints, dim], where dim is the dimension in 2-D or 3-D points
        * **openmp**: (type: boolean) Parallel or not

    ``Returns``:
        * **dist**: (type: 1D-ndarray). Distances in Angstroms between the ith atom and jth atoms in the same row of the ref and coor arrays
        * **rijx**: (type: 1D-ndarray). Component-x of the vector i,j
        * **rijy**: (type: 1D-ndarray). Component-y of the vector i,j
        * **rijz**: (type: 1D-ndarray). Component-z of the vector i,j

    ``Examples``:
    &gt;&gt;&gt;
    &gt;&gt;&gt;

    &#34;&#34;&#34;

    if openmp:
        from ext_libc.c_distances_openmp import calc_distance_diagonal_openmp
        #from c_distances_openmp import calc_distance_array_openmp
    else:
        from ext_libc.c_distances import calc_distance_diagonal
        #from c_distances import calc_distance_array

    rows = ref.shape[0]
    dist = np.zeros([rows])
    rijx = np.zeros([rows])
    rijy = np.zeros([rows])
    rijz = np.zeros([rows])
    if openmp:
        calc_distance_diagonal_openmp(ref, conf, dist, rijx, rijy, rijz)
    else:
        calc_distance_diagonal(ref, conf, dist, rijx, rijy, rijz)

    return dist, rijx, rijy, rijz

# #############################################################################
def distance_array_numpypython(ref, conf):

    &#34;&#34;&#34;Calculate the distances among the points in two arrays unsing pure pyhton and numpy

    ``Parameters``:
        * **ref**: (type: ndarray): Reference array containing a number of points with shape [npoints1, dim], where dim is the dimension in 2-D or 3-D points
        * **conf**: (type: ndarray): Reference array containing a number of points with shape [npoints2, dim], where dim is the dimension in 2-D or 3-D points
        * **openmp**: (type: boolean) Parallel or not

    ``Returns``:
        * **dist**: (type: 2D-ndarray). Distances in Angstroms between the ith atom (row) and the jth atoms
        * **rijx**: (type: 2D-ndarray). Component-x of the vector i,j
        * **rijy**: (type: 2D-ndarray). Component-y of the vector i,j
        * **rijz**: (type: 2D-ndarray). Component-z of the vector i,j
    ``Examples``:
    &gt;&gt;&gt;
    &gt;&gt;&gt;
    &gt;&gt;&gt;
    &gt;&gt;&gt;

    &#34;&#34;&#34;

    rows = ref.shape[0]
    cols = conf.shape[0]
    dist = np.zeros([rows,cols])
    rijx = np.zeros([rows,cols])
    rijy = np.zeros([rows,cols])
    rijz = np.zeros([rows,cols])
    irow = 0
    for ipoint in ref:
        icol = 0
        for jpoint in conf:
            rijx[irow, icol], rijy[irow, icol], rijz[irow, icol] = jpoint-ipoint
            dist[irow, icol] = np.linalg.norm(ipoint-jpoint)
            icol += 1
        irow += 1
    return dist, rijx, rijy, rijz

# #############################################################################
def distance_array_purepython(ref, conf):

    &#34;&#34;&#34;Calculate the distances among the points in two arrays unsing pure pyhton

    ``Parameters``:
        * **ref**: (type: ndarray): Reference array containing a number of points with shape [npoints1, dim], where dim is the dimension in 2-D or 3-D points
        * **conf**: (type: ndarray): Reference array containing a number of points with shape [npoints2, dim], where dim is the dimension in 2-D or 3-D points
        * **openmp**: (type: boolean) Parallel or not

    ``Returns``:
        * **dist**: (type: 2D-ndarray). Distances in Angstroms between the ith atom (row) and the jth atoms

    ``Examples``:
    &gt;&gt;&gt;
    &gt;&gt;&gt;
    &gt;&gt;&gt;
    &gt;&gt;&gt;

    &#34;&#34;&#34;

    rows = ref.shape[0]
    cols = conf.shape[0]
    dist = np.zeros([rows,cols])
    rijx = np.zeros([rows,cols])
    rijy = np.zeros([rows,cols])
    rijz = np.zeros([rows,cols])
    irow = 0
    for ipoint in ref:
        icol = 0
        for jpoint in conf:
            rijx[irow,icol] = jpoint[0] - ipoint[0]
            rijy[irow,icol] = jpoint[1] - ipoint[1]
            rijz[irow,icol] = jpoint[2] - ipoint[2]
            dist[irow, icol] = math.sqrt(rijx[irow,icol]*rijx[irow,icol]+

                                         rijy[irow,icol]*rijy[irow,icol]+
                                         rijz[irow,icol]*rijz[irow,icol])
            icol += 1
        irow += 1

    return dist, rijx, rijy, rijz

# #############################################################################
def bend_angle_purepython(c1, c2, c3, radians=False):


    &#34;&#34;&#34;
    Bend angle

    Finds angle between three atomic positions.
    Periodic boundary conditions are not taken into account, thus, coordinates must be unwrapped.
    This implementation is made in pure python, so it can be slow

        (1) --- (2) --- (3) (Bend angle 1-2-3)

    Parameters:
        * ``c1`` : Coordinates of the point 1
        * ``c2`` : Coordinates of the point 2
        * ``c3`` : Coordinates of the point 3
        * ``radians``: returns value in radians (degrees) if True (False)

    Returns:
        angle between particles in radians or degrees

    &#34;&#34;&#34;

    p12 = distance_array(c1.reshape(1,3), c2.reshape(1,3))
    p23 = distance_array(c2.reshape(1,3), c3.reshape(1,3))
    p13 = distance_array(c1.reshape(1,3), c3.reshape(1,3))

    theta = math.acos((pow(p12, 2.)+pow(p23, 2.)-pow(p13, 2.))/(2.*p12*p23))
    if not radians:
        theta = theta * 180. / math.pi
    return theta

# #############################################################################
def dihedral_angle_purepython(ci, cj, ck, cl, radians=False):

    &#34;&#34;&#34;

    Calculate the dihedral or improper angle

    .. image:: ../../figures/dih_imp.png

    Parameters:
        * ``ci`` :
        * ``cj`` :
        * ``ck`` :
        * ``cl`` :
        * ``radians`` :

    Returns:
        * ``phi`` :
    &#34;&#34;&#34;

    rij = ci - cj
    rjk = cj - ck
    rlk = cl - ck
    m = np.cross(rij, rjk)
    n = np.cross(rlk, rjk)
    m_norm = np.linalg.norm(m)
    n_norm = np.linalg.norm(n)
    cos_ijkl = np.dot(m,n)/(m_norm*n_norm)
    sin_ijkl = np.dot(n,rij)*np.linalg.norm(rjk)/(m_norm*n_norm)
    phi = -np.arctan(sin_ijkl/cos_ijkl)
    if not radians:
        phi = phi * 180. / math.pi
    return phi

# #############################################################################
def cos_angle_purepython(ci, cj, ck, cl, radians=False):

    &#34;&#34;&#34;
    Calculate the cos angle, used for bond perception in the paper
    Zhang et al. Journal of Cheminformatics 2012, 4:26 (Figure 4)
    (https://jcheminf.biomedcentral.com/articles/10.1186/1758-2946-4-26)

    .. image:: ../../figures/cos_angle.png

    Parameters:
        * ``ci`` :
        * ``cj`` :
        * ``ck`` :
        * ``cl`` :
        * ``radians`` :

    Returns:
        angle between particles in radians or degrees

    &#34;&#34;&#34;

    rji = cj - ci
    rki = ck - ci
    rli = cl - ci
    m = np.cross(rji, rki)

    m_norm = np.linalg.norm(m)
    rli_norm = np.linalg.norm(rli)

    cos_ijkl = np.dot(m,rli)/(m_norm*rli_norm)

    phi = np.arccos(cos_ijkl)
    if not radians:
        phi = phi * 180. / math.pi
    return phi

# #############################################################################
def generate_random_euler_angles(seed=None):

    &#34;&#34;&#34;

    Generate Euler angles.

    To generate an uniform sampling of the three Euler angles:

    .. image:: euler_angles_random.png

    There are many definitions of the Euler angles
    (see: https://en.wikipedia.org/wiki/Euler_angles)

    ``Parameters``:
        * **iseed**  (type: int): Seed for the random number generator

    ``Return``:
        * **A vector** containg the three Euler angles in radians

    &#34;&#34;&#34;

    if seed is None:
        random.seed()
    else:
        random.seed(seed)

    alpha  = 2.0 * math.pi * random.random()  #Radians
    c_beta = 1.0 - 2.0 * random.random()
    beta   = math.acos(c_beta)                  #Radians
    gamma  = 2.0 * math.pi * random.random()  #Radians

    return [alpha, beta, gamma]

# #############################################################################
def euler_rotation_matrix(euler):

        &#34;&#34;&#34;

        Create a rotation matrix for a given set of Euler angles
        There are many definitions of the Euler angles
        (see: https://en.wikipedia.org/wiki/Euler_angles)

        The definition here used is that given in:

        .. code-block::

            MATHEMATICAL METHODS FOR PHYSICISTS
            SEVENTH EDITION
            George B. Arfken, Hans J. Weber, Frank E. Harris
            pag: 140-142

        .. image:: euler_book.png

        ``Parameters``:
            * **None**

        ``Returns``:
            * **None**

        &#34;&#34;&#34;

        a = euler[0]
        b = euler[1]
        g = euler[2]
        ca = math.cos(a)
        cb = math.cos(b)
        cg = math.cos(g)
        sa = math.sin(a)
        sb = math.sin(b)
        sg = math.sin(g)

        S = np.array([ [( cg*cb*ca) - (sg*sa), ( cg*cb*sa) + (sg*ca), -cg*sb],
                       [(-sg*cb*ca) - (cg*sa), (-sg*cb*sa) + (cg*ca),  sg*sb],
                       [          sb*ca      ,            sb*sa     ,    cb]])

        return S

# #############################################################################
def center_of_geom(coords):

    &#34;&#34;&#34;
    Calculate the center of geometry of a set of coordinates.
    Periodic boundary conditions are not taken into account.
    This implementation is made in pure python, so it can be slow

    Parameters:
        * ``coords``: (type: list of ndarray-float32 (3)): Coordinates of the atoms. It must be unwrapped.

    Return:
        * ``cog`` (type: ndarray vector): Coordinates of the geometry center.

    &#34;&#34;&#34;

    if isinstance(coords,list):
        _coords = np.asarray(coords)
    elif isinstance(coords,np.ndarray):
        _coords = coords
    else:
        return None

    tmp = np.zeros(3)
    natoms = _coords.shape[0]
    for iatom in range(natoms):
        tmp += _coords[iatom,:]

    cog = tmp/natoms
    return cog</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="polyanagro.internal_coordinates.bend_angle_purepython"><code class="name flex">
<span>def <span class="ident">bend_angle_purepython</span></span>(<span>c1, c2, c3, radians=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Bend angle</p>
<p>Finds angle between three atomic positions.
Periodic boundary conditions are not taken into account, thus, coordinates must be unwrapped.
This implementation is made in pure python, so it can be slow</p>
<pre><code>(1) --- (2) --- (3) (Bend angle 1-2-3)
</code></pre>
<h2 id="parameters">Parameters</h2>
<ul>
<li><code>c1</code> : Coordinates of the point 1</li>
<li><code>c2</code> : Coordinates of the point 2</li>
<li><code>c3</code> : Coordinates of the point 3</li>
<li><code>radians</code>: returns value in radians (degrees) if True (False)</li>
</ul>
<h2 id="returns">Returns</h2>
<p>angle between particles in radians or degrees</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def bend_angle_purepython(c1, c2, c3, radians=False):


    &#34;&#34;&#34;
    Bend angle

    Finds angle between three atomic positions.
    Periodic boundary conditions are not taken into account, thus, coordinates must be unwrapped.
    This implementation is made in pure python, so it can be slow

        (1) --- (2) --- (3) (Bend angle 1-2-3)

    Parameters:
        * ``c1`` : Coordinates of the point 1
        * ``c2`` : Coordinates of the point 2
        * ``c3`` : Coordinates of the point 3
        * ``radians``: returns value in radians (degrees) if True (False)

    Returns:
        angle between particles in radians or degrees

    &#34;&#34;&#34;

    p12 = distance_array(c1.reshape(1,3), c2.reshape(1,3))
    p23 = distance_array(c2.reshape(1,3), c3.reshape(1,3))
    p13 = distance_array(c1.reshape(1,3), c3.reshape(1,3))

    theta = math.acos((pow(p12, 2.)+pow(p23, 2.)-pow(p13, 2.))/(2.*p12*p23))
    if not radians:
        theta = theta * 180. / math.pi
    return theta</code></pre>
</details>
</dd>
<dt id="polyanagro.internal_coordinates.center_of_geom"><code class="name flex">
<span>def <span class="ident">center_of_geom</span></span>(<span>coords)</span>
</code></dt>
<dd>
<div class="desc"><p>Calculate the center of geometry of a set of coordinates.
Periodic boundary conditions are not taken into account.
This implementation is made in pure python, so it can be slow</p>
<h2 id="parameters">Parameters</h2>
<ul>
<li><code>coords</code>: (type: list of ndarray-float32 (3)): Coordinates of the atoms. It must be unwrapped.</li>
</ul>
<h2 id="return">Return</h2>
<ul>
<li><code>cog</code> (type: ndarray vector): Coordinates of the geometry center.</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def center_of_geom(coords):

    &#34;&#34;&#34;
    Calculate the center of geometry of a set of coordinates.
    Periodic boundary conditions are not taken into account.
    This implementation is made in pure python, so it can be slow

    Parameters:
        * ``coords``: (type: list of ndarray-float32 (3)): Coordinates of the atoms. It must be unwrapped.

    Return:
        * ``cog`` (type: ndarray vector): Coordinates of the geometry center.

    &#34;&#34;&#34;

    if isinstance(coords,list):
        _coords = np.asarray(coords)
    elif isinstance(coords,np.ndarray):
        _coords = coords
    else:
        return None

    tmp = np.zeros(3)
    natoms = _coords.shape[0]
    for iatom in range(natoms):
        tmp += _coords[iatom,:]

    cog = tmp/natoms
    return cog</code></pre>
</details>
</dd>
<dt id="polyanagro.internal_coordinates.cos_angle_purepython"><code class="name flex">
<span>def <span class="ident">cos_angle_purepython</span></span>(<span>ci, cj, ck, cl, radians=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Calculate the cos angle, used for bond perception in the paper
Zhang et al. Journal of Cheminformatics 2012, 4:26 (Figure 4)
(<a href="https://jcheminf.biomedcentral.com/articles/10.1186/1758-2946-4-26">https://jcheminf.biomedcentral.com/articles/10.1186/1758-2946-4-26</a>)</p>
<p><img alt="" src="../../figures/cos_angle.png"></p>
<h2 id="parameters">Parameters</h2>
<ul>
<li><code>ci</code> :</li>
<li><code>cj</code> :</li>
<li><code>ck</code> :</li>
<li><code>cl</code> :</li>
<li><code>radians</code> :</li>
</ul>
<h2 id="returns">Returns</h2>
<p>angle between particles in radians or degrees</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def cos_angle_purepython(ci, cj, ck, cl, radians=False):

    &#34;&#34;&#34;
    Calculate the cos angle, used for bond perception in the paper
    Zhang et al. Journal of Cheminformatics 2012, 4:26 (Figure 4)
    (https://jcheminf.biomedcentral.com/articles/10.1186/1758-2946-4-26)

    .. image:: ../../figures/cos_angle.png

    Parameters:
        * ``ci`` :
        * ``cj`` :
        * ``ck`` :
        * ``cl`` :
        * ``radians`` :

    Returns:
        angle between particles in radians or degrees

    &#34;&#34;&#34;

    rji = cj - ci
    rki = ck - ci
    rli = cl - ci
    m = np.cross(rji, rki)

    m_norm = np.linalg.norm(m)
    rli_norm = np.linalg.norm(rli)

    cos_ijkl = np.dot(m,rli)/(m_norm*rli_norm)

    phi = np.arccos(cos_ijkl)
    if not radians:
        phi = phi * 180. / math.pi
    return phi</code></pre>
</details>
</dd>
<dt id="polyanagro.internal_coordinates.dihedral_angle_purepython"><code class="name flex">
<span>def <span class="ident">dihedral_angle_purepython</span></span>(<span>ci, cj, ck, cl, radians=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Calculate the dihedral or improper angle</p>
<p><img alt="" src="../../figures/dih_imp.png"></p>
<h2 id="parameters">Parameters</h2>
<ul>
<li><code>ci</code> :</li>
<li><code>cj</code> :</li>
<li><code>ck</code> :</li>
<li><code>cl</code> :</li>
<li><code>radians</code> :</li>
</ul>
<h2 id="returns">Returns</h2>
<ul>
<li><code>phi</code> :</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def dihedral_angle_purepython(ci, cj, ck, cl, radians=False):

    &#34;&#34;&#34;

    Calculate the dihedral or improper angle

    .. image:: ../../figures/dih_imp.png

    Parameters:
        * ``ci`` :
        * ``cj`` :
        * ``ck`` :
        * ``cl`` :
        * ``radians`` :

    Returns:
        * ``phi`` :
    &#34;&#34;&#34;

    rij = ci - cj
    rjk = cj - ck
    rlk = cl - ck
    m = np.cross(rij, rjk)
    n = np.cross(rlk, rjk)
    m_norm = np.linalg.norm(m)
    n_norm = np.linalg.norm(n)
    cos_ijkl = np.dot(m,n)/(m_norm*n_norm)
    sin_ijkl = np.dot(n,rij)*np.linalg.norm(rjk)/(m_norm*n_norm)
    phi = -np.arctan(sin_ijkl/cos_ijkl)
    if not radians:
        phi = phi * 180. / math.pi
    return phi</code></pre>
</details>
</dd>
<dt id="polyanagro.internal_coordinates.distance_array"><code class="name flex">
<span>def <span class="ident">distance_array</span></span>(<span>ref, conf, openmp=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Calculate the distances among the points in two arrays using C and Cython</p>
<h2 id="parameters">Parameters</h2>
<ul>
<li><code>ref</code>: (type: ndarray): Reference array containing a number of points with shape [npoints1, dim], where dim is the dimension in 2-D or 3-D points</li>
<li><code>conf</code>: (type: ndarray): Reference array containing a number of points with shape [npoints2, dim], where dim is the dimension in 2-D or 3-D points</li>
<li><code>openmp</code>: (type: boolean) Parallel or not</li>
</ul>
<h2 id="returns">Returns</h2>
<ul>
<li><code>dist</code>: (type: 2D-ndarray). Distances in Angstroms between the ith atom (row) and the jth atoms</li>
<li><code>rijx</code>: (type: 2D-ndarray). Component-x of the vector i,j</li>
<li><code>rijy</code>: (type: 2D-ndarray). Component-y of the vector i,j</li>
<li><code>rijz</code>: (type: 2D-ndarray). Component-z of the vector i,j
<code>Examples</code>:</li>
</ul>
<pre><code class="python">&gt;&gt;&gt; a
&gt;&gt;&gt; a
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def distance_array(ref, conf, openmp=False):
    &#34;&#34;&#34;
    Calculate the distances among the points in two arrays using C and Cython

    Parameters:
        * ``ref``: (type: ndarray): Reference array containing a number of points with shape [npoints1, dim], where dim is the dimension in 2-D or 3-D points
        * ``conf``: (type: ndarray): Reference array containing a number of points with shape [npoints2, dim], where dim is the dimension in 2-D or 3-D points
        * ``openmp``: (type: boolean) Parallel or not

    Returns:
        * ``dist``: (type: 2D-ndarray). Distances in Angstroms between the ith atom (row) and the jth atoms
        * ``rijx``: (type: 2D-ndarray). Component-x of the vector i,j
        * ``rijy``: (type: 2D-ndarray). Component-y of the vector i,j
        * ``rijz``: (type: 2D-ndarray). Component-z of the vector i,j

    ``Examples``:
    &gt;&gt;&gt; a
    &gt;&gt;&gt; a

    &#34;&#34;&#34;

    if openmp:
        from ext_libc.c_distances_openmp import calc_distance_array_openmp
        #from c_distances_openmp import calc_distance_array_openmp
    else:
        from ext_libc.c_distances import calc_distance_array
        #from c_distances import calc_distance_array

    rows = ref.shape[0]
    cols = conf.shape[0]
    dist = np.zeros([rows,cols])
    rijx = np.zeros([rows,cols])
    rijy = np.zeros([rows,cols])
    rijz = np.zeros([rows,cols])
    if openmp:
        calc_distance_array_openmp(ref, conf, dist, rijx, rijy, rijz)
    else:
        calc_distance_array(ref, conf, dist, rijx, rijy, rijz)

    return dist, rijx, rijy, rijz</code></pre>
</details>
</dd>
<dt id="polyanagro.internal_coordinates.distance_array_numpypython"><code class="name flex">
<span>def <span class="ident">distance_array_numpypython</span></span>(<span>ref, conf)</span>
</code></dt>
<dd>
<div class="desc"><p>Calculate the distances among the points in two arrays unsing pure pyhton and numpy</p>
<p><code>Parameters</code>:
* <strong>ref</strong>: (type: ndarray): Reference array containing a number of points with shape [npoints1, dim], where dim is the dimension in 2-D or 3-D points
* <strong>conf</strong>: (type: ndarray): Reference array containing a number of points with shape [npoints2, dim], where dim is the dimension in 2-D or 3-D points
* <strong>openmp</strong>: (type: boolean) Parallel or not</p>
<p><code>Returns</code>:
* <strong>dist</strong>: (type: 2D-ndarray). Distances in Angstroms between the ith atom (row) and the jth atoms
* <strong>rijx</strong>: (type: 2D-ndarray). Component-x of the vector i,j
* <strong>rijy</strong>: (type: 2D-ndarray). Component-y of the vector i,j
* <strong>rijz</strong>: (type: 2D-ndarray). Component-z of the vector i,j
<code>Examples</code>:</p>
<blockquote>
<blockquote>
<blockquote></blockquote>
</blockquote>
</blockquote></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def distance_array_numpypython(ref, conf):

    &#34;&#34;&#34;Calculate the distances among the points in two arrays unsing pure pyhton and numpy

    ``Parameters``:
        * **ref**: (type: ndarray): Reference array containing a number of points with shape [npoints1, dim], where dim is the dimension in 2-D or 3-D points
        * **conf**: (type: ndarray): Reference array containing a number of points with shape [npoints2, dim], where dim is the dimension in 2-D or 3-D points
        * **openmp**: (type: boolean) Parallel or not

    ``Returns``:
        * **dist**: (type: 2D-ndarray). Distances in Angstroms between the ith atom (row) and the jth atoms
        * **rijx**: (type: 2D-ndarray). Component-x of the vector i,j
        * **rijy**: (type: 2D-ndarray). Component-y of the vector i,j
        * **rijz**: (type: 2D-ndarray). Component-z of the vector i,j
    ``Examples``:
    &gt;&gt;&gt;
    &gt;&gt;&gt;
    &gt;&gt;&gt;
    &gt;&gt;&gt;

    &#34;&#34;&#34;

    rows = ref.shape[0]
    cols = conf.shape[0]
    dist = np.zeros([rows,cols])
    rijx = np.zeros([rows,cols])
    rijy = np.zeros([rows,cols])
    rijz = np.zeros([rows,cols])
    irow = 0
    for ipoint in ref:
        icol = 0
        for jpoint in conf:
            rijx[irow, icol], rijy[irow, icol], rijz[irow, icol] = jpoint-ipoint
            dist[irow, icol] = np.linalg.norm(ipoint-jpoint)
            icol += 1
        irow += 1
    return dist, rijx, rijy, rijz</code></pre>
</details>
</dd>
<dt id="polyanagro.internal_coordinates.distance_array_purepython"><code class="name flex">
<span>def <span class="ident">distance_array_purepython</span></span>(<span>ref, conf)</span>
</code></dt>
<dd>
<div class="desc"><p>Calculate the distances among the points in two arrays unsing pure pyhton</p>
<p><code>Parameters</code>:
* <strong>ref</strong>: (type: ndarray): Reference array containing a number of points with shape [npoints1, dim], where dim is the dimension in 2-D or 3-D points
* <strong>conf</strong>: (type: ndarray): Reference array containing a number of points with shape [npoints2, dim], where dim is the dimension in 2-D or 3-D points
* <strong>openmp</strong>: (type: boolean) Parallel or not</p>
<p><code>Returns</code>:
* <strong>dist</strong>: (type: 2D-ndarray). Distances in Angstroms between the ith atom (row) and the jth atoms</p>
<p><code>Examples</code>:</p>
<blockquote>
<blockquote>
<blockquote></blockquote>
</blockquote>
</blockquote></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def distance_array_purepython(ref, conf):

    &#34;&#34;&#34;Calculate the distances among the points in two arrays unsing pure pyhton

    ``Parameters``:
        * **ref**: (type: ndarray): Reference array containing a number of points with shape [npoints1, dim], where dim is the dimension in 2-D or 3-D points
        * **conf**: (type: ndarray): Reference array containing a number of points with shape [npoints2, dim], where dim is the dimension in 2-D or 3-D points
        * **openmp**: (type: boolean) Parallel or not

    ``Returns``:
        * **dist**: (type: 2D-ndarray). Distances in Angstroms between the ith atom (row) and the jth atoms

    ``Examples``:
    &gt;&gt;&gt;
    &gt;&gt;&gt;
    &gt;&gt;&gt;
    &gt;&gt;&gt;

    &#34;&#34;&#34;

    rows = ref.shape[0]
    cols = conf.shape[0]
    dist = np.zeros([rows,cols])
    rijx = np.zeros([rows,cols])
    rijy = np.zeros([rows,cols])
    rijz = np.zeros([rows,cols])
    irow = 0
    for ipoint in ref:
        icol = 0
        for jpoint in conf:
            rijx[irow,icol] = jpoint[0] - ipoint[0]
            rijy[irow,icol] = jpoint[1] - ipoint[1]
            rijz[irow,icol] = jpoint[2] - ipoint[2]
            dist[irow, icol] = math.sqrt(rijx[irow,icol]*rijx[irow,icol]+

                                         rijy[irow,icol]*rijy[irow,icol]+
                                         rijz[irow,icol]*rijz[irow,icol])
            icol += 1
        irow += 1

    return dist, rijx, rijy, rijz</code></pre>
</details>
</dd>
<dt id="polyanagro.internal_coordinates.distance_diagonal_array"><code class="name flex">
<span>def <span class="ident">distance_diagonal_array</span></span>(<span>ref, conf, openmp=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Calculate the distances among the points in two arrays using C and Cython</p>
<p><code>Parameters</code>:
* <strong>ref</strong>: (type: ndarray): Reference array containing a number of points with shape [npoints, dim], where dim is the dimension in 2-D or 3-D points
* <strong>conf</strong>: (type: ndarray): Reference array containing a number of points with shape [npoints, dim], where dim is the dimension in 2-D or 3-D points
* <strong>openmp</strong>: (type: boolean) Parallel or not</p>
<p><code>Returns</code>:
* <strong>dist</strong>: (type: 1D-ndarray). Distances in Angstroms between the ith atom and jth atoms in the same row of the ref and coor arrays
* <strong>rijx</strong>: (type: 1D-ndarray). Component-x of the vector i,j
* <strong>rijy</strong>: (type: 1D-ndarray). Component-y of the vector i,j
* <strong>rijz</strong>: (type: 1D-ndarray). Component-z of the vector i,j</p>
<p><code>Examples</code>:</p>
<blockquote>
<blockquote>
<blockquote></blockquote>
</blockquote>
</blockquote></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def distance_diagonal_array(ref, conf, openmp=False):
    &#34;&#34;&#34;Calculate the distances among the points in two arrays using C and Cython

    ``Parameters``:
        * **ref**: (type: ndarray): Reference array containing a number of points with shape [npoints, dim], where dim is the dimension in 2-D or 3-D points
        * **conf**: (type: ndarray): Reference array containing a number of points with shape [npoints, dim], where dim is the dimension in 2-D or 3-D points
        * **openmp**: (type: boolean) Parallel or not

    ``Returns``:
        * **dist**: (type: 1D-ndarray). Distances in Angstroms between the ith atom and jth atoms in the same row of the ref and coor arrays
        * **rijx**: (type: 1D-ndarray). Component-x of the vector i,j
        * **rijy**: (type: 1D-ndarray). Component-y of the vector i,j
        * **rijz**: (type: 1D-ndarray). Component-z of the vector i,j

    ``Examples``:
    &gt;&gt;&gt;
    &gt;&gt;&gt;

    &#34;&#34;&#34;

    if openmp:
        from ext_libc.c_distances_openmp import calc_distance_diagonal_openmp
        #from c_distances_openmp import calc_distance_array_openmp
    else:
        from ext_libc.c_distances import calc_distance_diagonal
        #from c_distances import calc_distance_array

    rows = ref.shape[0]
    dist = np.zeros([rows])
    rijx = np.zeros([rows])
    rijy = np.zeros([rows])
    rijz = np.zeros([rows])
    if openmp:
        calc_distance_diagonal_openmp(ref, conf, dist, rijx, rijy, rijz)
    else:
        calc_distance_diagonal(ref, conf, dist, rijx, rijy, rijz)

    return dist, rijx, rijy, rijz</code></pre>
</details>
</dd>
<dt id="polyanagro.internal_coordinates.euler_rotation_matrix"><code class="name flex">
<span>def <span class="ident">euler_rotation_matrix</span></span>(<span>euler)</span>
</code></dt>
<dd>
<div class="desc"><p>Create a rotation matrix for a given set of Euler angles
There are many definitions of the Euler angles
(see: <a href="https://en.wikipedia.org/wiki/Euler_angles">https://en.wikipedia.org/wiki/Euler_angles</a>)</p>
<p>The definition here used is that given in:</p>
<p>.. code-block::</p>
<pre><code>MATHEMATICAL METHODS FOR PHYSICISTS
SEVENTH EDITION
George B. Arfken, Hans J. Weber, Frank E. Harris
pag: 140-142
</code></pre>
<p><img alt="" src="euler_book.png"></p>
<p><code>Parameters</code>:
* <strong>None</strong></p>
<p><code>Returns</code>:
* <strong>None</strong></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def euler_rotation_matrix(euler):

        &#34;&#34;&#34;

        Create a rotation matrix for a given set of Euler angles
        There are many definitions of the Euler angles
        (see: https://en.wikipedia.org/wiki/Euler_angles)

        The definition here used is that given in:

        .. code-block::

            MATHEMATICAL METHODS FOR PHYSICISTS
            SEVENTH EDITION
            George B. Arfken, Hans J. Weber, Frank E. Harris
            pag: 140-142

        .. image:: euler_book.png

        ``Parameters``:
            * **None**

        ``Returns``:
            * **None**

        &#34;&#34;&#34;

        a = euler[0]
        b = euler[1]
        g = euler[2]
        ca = math.cos(a)
        cb = math.cos(b)
        cg = math.cos(g)
        sa = math.sin(a)
        sb = math.sin(b)
        sg = math.sin(g)

        S = np.array([ [( cg*cb*ca) - (sg*sa), ( cg*cb*sa) + (sg*ca), -cg*sb],
                       [(-sg*cb*ca) - (cg*sa), (-sg*cb*sa) + (cg*ca),  sg*sb],
                       [          sb*ca      ,            sb*sa     ,    cb]])

        return S</code></pre>
</details>
</dd>
<dt id="polyanagro.internal_coordinates.generate_random_euler_angles"><code class="name flex">
<span>def <span class="ident">generate_random_euler_angles</span></span>(<span>seed=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Generate Euler angles.</p>
<p>To generate an uniform sampling of the three Euler angles:</p>
<p><img alt="" src="euler_angles_random.png"></p>
<p>There are many definitions of the Euler angles
(see: <a href="https://en.wikipedia.org/wiki/Euler_angles">https://en.wikipedia.org/wiki/Euler_angles</a>)</p>
<p><code>Parameters</code>:
* <strong>iseed</strong>
(type: int): Seed for the random number generator</p>
<p><code>Return</code>:
* <strong>A vector</strong> containg the three Euler angles in radians</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def generate_random_euler_angles(seed=None):

    &#34;&#34;&#34;

    Generate Euler angles.

    To generate an uniform sampling of the three Euler angles:

    .. image:: euler_angles_random.png

    There are many definitions of the Euler angles
    (see: https://en.wikipedia.org/wiki/Euler_angles)

    ``Parameters``:
        * **iseed**  (type: int): Seed for the random number generator

    ``Return``:
        * **A vector** containg the three Euler angles in radians

    &#34;&#34;&#34;

    if seed is None:
        random.seed()
    else:
        random.seed(seed)

    alpha  = 2.0 * math.pi * random.random()  #Radians
    c_beta = 1.0 - 2.0 * random.random()
    beta   = math.acos(c_beta)                  #Radians
    gamma  = 2.0 * math.pi * random.random()  #Radians

    return [alpha, beta, gamma]</code></pre>
</details>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="polyanagro" href="index.html">polyanagro</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="polyanagro.internal_coordinates.bend_angle_purepython" href="#polyanagro.internal_coordinates.bend_angle_purepython">bend_angle_purepython</a></code></li>
<li><code><a title="polyanagro.internal_coordinates.center_of_geom" href="#polyanagro.internal_coordinates.center_of_geom">center_of_geom</a></code></li>
<li><code><a title="polyanagro.internal_coordinates.cos_angle_purepython" href="#polyanagro.internal_coordinates.cos_angle_purepython">cos_angle_purepython</a></code></li>
<li><code><a title="polyanagro.internal_coordinates.dihedral_angle_purepython" href="#polyanagro.internal_coordinates.dihedral_angle_purepython">dihedral_angle_purepython</a></code></li>
<li><code><a title="polyanagro.internal_coordinates.distance_array" href="#polyanagro.internal_coordinates.distance_array">distance_array</a></code></li>
<li><code><a title="polyanagro.internal_coordinates.distance_array_numpypython" href="#polyanagro.internal_coordinates.distance_array_numpypython">distance_array_numpypython</a></code></li>
<li><code><a title="polyanagro.internal_coordinates.distance_array_purepython" href="#polyanagro.internal_coordinates.distance_array_purepython">distance_array_purepython</a></code></li>
<li><code><a title="polyanagro.internal_coordinates.distance_diagonal_array" href="#polyanagro.internal_coordinates.distance_diagonal_array">distance_diagonal_array</a></code></li>
<li><code><a title="polyanagro.internal_coordinates.euler_rotation_matrix" href="#polyanagro.internal_coordinates.euler_rotation_matrix">euler_rotation_matrix</a></code></li>
<li><code><a title="polyanagro.internal_coordinates.generate_random_euler_angles" href="#polyanagro.internal_coordinates.generate_random_euler_angles">generate_random_euler_angles</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.8.4</a>.</p>
</footer>
</body>
</html>